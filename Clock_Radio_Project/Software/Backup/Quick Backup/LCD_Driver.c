//LCD Display driver for NOKIA 5110
//Author: Nick Schrock, Kevin Sager
//written in reference to https://github.com/mspiceland/avr-spiceduino-3310-thermistor

/***************************************************************************************
This module is the primary driver for the LCD Display screen.  These functions are 
used and called in various parts of the system to draw the correct images on to the LCD
display.  The functions can get fairly intricate but their functionality is mostly 
self-explanatory.
****************************************************************************************/

#include <avr/io.h>
#include "LCD_Driver.h"
#include "SPI_Driver.h"
#include <avr/pgmspace.h>
#include <math.h>
#include <stdbool.h>

int current_row = 0;
int current_col = 0;

static unsigned char lcd_buffer[8][84];

//Splash Screen data.  Currently Thermometer
//TODO: Customize a cool Splash screen for startup
unsigned const char splash[7][84] PROGMEM = {
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x20,0x20,0xc0,0x00,0xe0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0x60,0x20,0x60,0xc0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x1f,0x02,0x02,0x00,0x00,0x80,0x84,0x84,0x84,0x84,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x84,0x84,0x84,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x84,0x84,0x84,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x84,0x84,0x84,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x90,0xd0,0x7f,0x00,0x00,0x00,0x00,0x00,0x7f,0xd0,0x90,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0xe3,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xe3,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x02,0x02,0x02,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
};

//Data Array for drawing a bell
unsigned const char bell[9] PROGMEM = {0x40,0x60,0x7C,0xFE,0xFF,0xFE,0x7C,0x60,0x40};
	
unsigned const char note[9] PROGMEM = {0x07,0x01,0x4D,0xE4,0xE0,0xE0,0x7F,0x06,0x0C};
	
//Data Array for drawing a large colon
//TODO: Make it look better / more defined
unsigned const char colon[3][16] = {
	{0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},			//':'
	{0,0,0,0,0,0,0,129,129,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,128,128,0,0,0,0,0,0,0}
};

//Initialize LCD by clearing and resetting pins
void LCD_Init(void){
	
	CLEAR_RST_PIN;
	CLEAR_SCE_PIN;

	SET_RST_PIN;
	SET_SCE_PIN;
	
	LCD_WriteCommand( 0x21 );  // LCD Extended Commands.
	LCD_WriteCommand( 0xC0 );  // Set LCD Vop (Contrast).
	LCD_WriteCommand( 0x04 );  // Set Temp coefficent.
	LCD_WriteCommand( 0x13 );  // LCD bias mode 1:48.
	LCD_WriteCommand( 0x20 );  // LCD Standard Commands, Horizontal addressing mode.
	LCD_WriteCommand( 0x0c );  // LCD in normal mode.

	LCD_Clear();
}

//Sends commands to LCD control register
void LCD_WriteCommand(unsigned char command){
	CLEAR_SCE_PIN;		//disable LCD
	CLEAR_DC_PIN;		//set to command mode
	SPI_Master_Send(command);
}

//Writes 8 vertically aligned pixels
void LCD_WriteData(unsigned char data){
	CLEAR_SCE_PIN;
	SET_DC_PIN;
	SPI_Master_Send(data);
}

//Places cursor at specific location
void LCD_GoTo(uint8_t x, uint8_t y){
	LCD_WriteCommand(0x80 | x);
	LCD_WriteCommand(0x40 | y);

	current_row = y;
	current_col = x;
}

//Clears Screen
void LCD_Clear(void){
	int i,j;
	
	LCD_GoTo(0,0);  	//start with (0,0) position

	for(i=0; i<8; i++)
	{
		for(j=0; j<90; j++)
		{
			LCD_WriteData( 0x00 );
			if ((i < 6) && (j < 84))
				lcd_buffer[i][j] = 0x00;
		}
	}
   
    LCD_GoTo(0,0);	//bring the XY position back to (0,0)
}

//Write Zero's to 5 spaces and return to original position
void LCD_ClearSmallSpace(void){
	for(int i=0; i<6; i++){
		lcd_buffer[current_row][current_col+i] = 0x00;
	}
}

//Writes 0's to large space and returns to original position
void LCD_ClearLargeSpace(void){
	for(int i=0; i<3; i++){
		for(int j=0; j<10; j++){
			if((current_row+i)<10 && (current_col+j)<94)
				lcd_buffer[current_row-i][current_col+j] = 0x00;
		}
	}
}

//Updates screen to whatever is contained in the buffer
void LCD_Update( void )
{
	int i,j;
	
	LCD_GoTo(0,0);  	//start with (0,0) position

	for(i=0; i<7; i++)
	{
		LCD_GoTo(0,i);
		for(j=0; j<84; j++)
		{
			LCD_WriteData(lcd_buffer[i][j]);
		}
	}
   
	LCD_GoTo(0,0);	//bring the XY position back to (0,0)
      
}

//Draws whatever is in the Splash data array onto the screen
void LCD_DrawSplash(void){
		
	int i,j;

	for(i=0; i<7; i++){
		for(j=0; j<84; j++){
			lcd_buffer[i][j] = pgm_read_byte(&(splash[i][j]));
		}
	}
		LCD_Update();
}

//Draws Colon data array
void LCD_WriteColon(){
	LCD_DisplayLargeInt(13);
}

//Draws Alarm Indicator Bell
void LCD_DrawBell(int x, int y){
	for(int i=0; i<9; i++){
		lcd_buffer[x][y+i] = pgm_read_byte(&(bell[i]));
	}
	LCD_Update();
}

void LCD_DrawNote(int x, int y){
	for(int i=0; i<9; i++){
		lcd_buffer[x][y+i] = pgm_read_byte(&(note[i]));
	}
	LCD_Update();
}

void LCD_DrawBar(int y, int x, uint8_t height){
	lcd_buffer[x][y] = height;
	lcd_buffer[x][y+1] = height;
	LCD_Update();
}


//Sets one individual pixel
void LCD_SetPixel(uint8_t x, uint8_t y){
	uint8_t row = y/8;
	uint8_t value;

	value = lcd_buffer[row][x];
	value |= (1 << (y%8));
	lcd_buffer[row][x] = value;

	LCD_GoTo(x,row);
	LCD_Update();
}

//Clears one individual pixel
void LCD_ClearPixel( uint8_t x, uint8_t y )
{
	unsigned char value;
	unsigned char row;
	
	row = y / 8;

	value = lcd_buffer[row][x];
	value &= ~(1 << (y % 8));
	lcd_buffer[row][x] = value;

	LCD_Update();
	LCD_GoTo(x,row);
}

//Writes character to screen
void LCD_WriteChar (unsigned char ch)
{
	unsigned char j;

	//clear a small space before every writing a character to ensure no overlap
	LCD_ClearSmallSpace();
  
	lcd_buffer[current_row][current_col] = 0x00;
	for(j=0; j<5; j++)
		lcd_buffer[current_row][current_col + j] |=  pgm_read_byte(&(smallFont [(ch-32)*5 + j] ));

	lcd_buffer[current_row][current_col + 6] = 0x00;

	//Write data in buffer to screen
	for(j=0; j<7; j++)
		LCD_WriteData(lcd_buffer[current_row][current_col++]);
}

//Write data type Integer to screen. Used for displaying Time/date
void LCD_WriteInt (uint8_t i, bool large){
	int first_digit = digitAtPos(i,2);
	int second_digit = digitAtPos(i,1);
			
	if (i<10){
		if(large){
			//LCD_ClearLargeSpace();
			LCD_DisplayLargeInt(i);
		}
		else{
			LCD_ClearSmallSpace();
			LCD_DisplaySmallInt(i);
		}
	}
	else{
		if(large){
			if(second_digit == 0)
				LCD_ClearLargeSpace();
			LCD_DisplayLargeInt(first_digit);
			LCD_GoTo(current_col+13, current_row);
			LCD_ClearLargeSpace();
			LCD_DisplayLargeInt(second_digit);
		}
		else{
			if(second_digit == 0)
				LCD_ClearSmallSpace();
			LCD_DisplaySmallInt(first_digit);
			LCD_ClearSmallSpace();
			LCD_DisplaySmallInt(second_digit);
		}
	}
}

//Write a small integer to screen
void LCD_DisplaySmallInt(uint8_t i){
	int j;
	lcd_buffer[current_row][current_col] = 0x00;
	for(j=0; j<5; j++)
		lcd_buffer[current_row][current_col + j] |=  pgm_read_byte(&(smallFont [(i+16)*5 + j] ));

	lcd_buffer[current_row][current_col + 6] = 0x00;

	for(j=0; j<7; j++)
		LCD_WriteData(lcd_buffer[current_row][current_col++]);
}

//Actually draws the large integer to the screen... 
//The reason for this function is to factor out this mildly complex algorithm
void LCD_DisplayLargeInt(uint8_t num){
	int i,j;
	for(i=0;i<3;i++)
	{	
		LCD_GoTo(current_col, i);
		
		for(j=0; j<16; j++) {
			lcd_buffer[current_row][current_col + j] =  pgm_read_byte(&(number[num][i][j]));
			LCD_WriteData(lcd_buffer[current_row][current_col + j]);
		}
	}
}

int digitAtPos(int number, int pos)
{
	return ( number / (int)pow(10.0, pos-1) ) % 10;
}


void LCD_WriteString(const char *string)
{
	while ( *string )
		LCD_WriteChar( *string++ );
}

//Highlights a row on the screen
void LCD_InvertRow(int row){
	for(int i=0; i<84; i++){
		lcd_buffer[row][i] ^= 0xFF;
	}
	LCD_Update();
}

